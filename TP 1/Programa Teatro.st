Object subclass: #Direccion	instanceVariableNames: 'nombre apellido porcentajeVentas'	classVariableNames: ''	package: 'Programa Teatro'!!Direccion methodsFor: 'acceso'!porcentajeVentas"Devuelve la porcentajeVentas de la direccion"^porcentajeVentas! !!Direccion methodsFor: 'acceso'!nombre"Devuelve el nombre"^nombre ! !!Direccion methodsFor: 'acceso' stamp: 'Fede 5/2/2022 20:15'!asString"Devuelve el valor de todas las variables como string"|res|res := String cr, 'Nombre: ', self nombre asString, ' - Apellido: ', self apellido asString,' - porcentaje de Ventas: ', self porcentajeVentas asString, String cr.^res! !!Direccion methodsFor: 'acceso'!apellido"Devuelve el apellido del director"^apellido ! !!Direccion methodsFor: 'modificacion'!nombre: elNombre"M‚àö¬©todo modificador de la variable nombre"(elNombre isKindOf: String) ifTrue: [nombre:= elNombre]. ! !!Direccion methodsFor: 'modificacion'!apellido: elApellido"M‚àö¬©todo de modificacion de la variable apellido"(elApellido isKindOf: String) ifTrue: [apellido := elApellido].! !!Direccion methodsFor: 'modificacion' stamp: 'Fede 5/2/2022 19:23'!porcentajeVentas: unPorcentajeVentas"M‚àö¬©todo de modificacion de porcentajeVentas"((unPorcentajeVentas between: 0 and: 100)&(unPorcentajeVentas isKindOf: Float))  ifTrue: [porcentajeVentas := unPorcentajeVentas].! !!Direccion methodsFor: 'inicializacion' stamp: 'Fede 5/1/2022 17:13'!initializesuper initialize."Inicializacion de los Variables de Direccion"nombre:= ''.apellido := ''.porcentajeVentas := 0.! !Object subclass: #Entrada	instanceVariableNames: 'importeBasico vendida'	classVariableNames: ''	package: 'Programa Teatro'!!Entrada methodsFor: 'modificacion'!importeBasico: unImporteNuevo"Cambie el valor del importeBasico si permitido"((unImporteNuevo > 0) & (unImporteNuevo isKindOf: Number)) ifTrue: [importeBasico :=unImporteNuevo]! !!Entrada methodsFor: 'modificacion'!vendida: nuevoEsadoDeVendida"Acceso a la variable vendida"(nuevoEsadoDeVendida isKindOf: Boolean) ifTrue: [vendida := nuevoEsadoDeVendida].! !!Entrada methodsFor: 'control' stamp: 'Fede 5/1/2022 17:17'!importeFinal^self subclassResponsibility.! !!Entrada methodsFor: 'acceso' stamp: 'Fede 5/2/2022 20:23'!asString"Devuelve el valor de todas las variables como string"|res|res := '- Vendida: ', self vendida asString, ' - Importe basico: ', self importeBasico asString, String cr.^res! !!Entrada methodsFor: 'acceso'!importeBasico"Metodo de acceso de la variable importeBasico"^importeBasico.! !!Entrada methodsFor: 'acceso'!vendida"metodo de acceso a la variable vendida"^vendida.! !!Entrada methodsFor: 'initialization' stamp: 'Fede 5/1/2022 17:13'!initialize super initialize."En el principio una Entrada no es vendida y la importeBasico esta 0"vendida := false.importeBasico := 0.! !Entrada subclass: #EntradaPlatea	instanceVariableNames: 'nroButaca'	classVariableNames: ''	package: 'Programa Teatro'!!EntradaPlatea methodsFor: 'modificacion' stamp: 'Fede 5/2/2022 18:38'!nroButaca: nuevoNumero"Metodo de modificacion de nroButaca"(nuevoNumero isKindOf: Integer) & (nuevoNumero odd) ifTrue: [nroButaca := nuevoNumero].! !!EntradaPlatea methodsFor: 'control' stamp: 'Fede 5/1/2022 17:24'!importeFinal	|res|	res:= 0.	(nroButaca < 50) ifTrue: [ res:= importeBasico * 1.25. ]	ifFalse: [ res:= importeBasico * 1.1 ].	^res! !!EntradaPlatea methodsFor: 'initialization'!initialize "Metodo de initializacion de EntradaPlatea""Inicializar atributos heredados de la clase base: Entrada" super initialize."Inicializar los atributos propios"nroButaca  := 0.! !!EntradaPlatea methodsFor: 'acceso'!nroButaca"Metodo de acceso al nroButaca"^nroButaca.! !!EntradaPlatea methodsFor: 'acceso' stamp: 'Fede 5/2/2022 20:18'!asString"Devuelve el valor de todas las variables como string"|res|res := String cr,' - Entrada de butaca numero: ', self nroButaca asString, String cr, ' ', super asString, String cr.^res! !Entrada subclass: #EntradaVip	instanceVariableNames: 'palco servicioCatering'	classVariableNames: ''	package: 'Programa Teatro'!!EntradaVip methodsFor: 'acceso'!servicioCatering"Metodo de acceso a la variable servicioCatering"^servicioCatering.! !!EntradaVip methodsFor: 'acceso' stamp: 'Fede 5/2/2022 20:46'!asString"Devuelve el valor de todas las variables como string"|res|res := ' - Entrada VIP para el Palco: ', self palco asString,  String cr,' - Catering selecionado: ', self servicioCatering asString, ' ', super asString.^res! !!EntradaVip methodsFor: 'acceso'!palco"Metodo de acceso del palco"^palco.! !!EntradaVip methodsFor: 'modificacion'!palco: palcoNuevo"Cambie el palco para un objeto de la clase Palco: palcoNuveo"	(palcoNuevo isKindOf: Palco ) ifTrue: [palco:= palcoNuevo].! !!EntradaVip methodsFor: 'modificacion' stamp: 'Fede 5/2/2022 20:40'!servicioCatering: nuevoEstadoCatering"Cambie la variable servicioCatering a un nuevo Valor: nuevoEstadoCatering si es un objeto booleano"(nuevoEstadoCatering isKindOf: Boolean) ifTrue: [servicioCatering := nuevoEstadoCatering.].! !!EntradaVip methodsFor: 'initialization'!initialize "Metodo de initializacion de EntradaVip""Inicializar atributos heredados de la clase base: Entrada" super initialize."Inicializar los atributos propios"palco := 'Todavia no asignado'.servicioCatering := false. "Default = false"! !!EntradaVip methodsFor: 'control' stamp: 'Fede 5/1/2022 17:27'!importeFinal|res|	res:= importeBasico * palco cantidadAsientos.		servicioCatering ifTrue: [ res:= res * 1.3. ].	^res.! !Object subclass: #Funcion	instanceVariableNames: 'codigo fecha entradas'	classVariableNames: ''	package: 'Programa Teatro'!!Funcion methodsFor: 'control' stamp: 'Fede 5/1/2022 19:00'!encontrarEntrada|entrada|	entrada:= entradas detect: [ :x | ((x vendida) not) & (x isKindOf: EntradaPlatea)] ifNone: [entrada:= nil].	^entrada.! !!Funcion methodsFor: 'control' stamp: 'Fede 5/2/2022 21:13'!buscarEntradasNoVendidas|res|res:= entradas select: [ :x | (x vendida not) & (x isKindOf: EntradaPlatea)].^res! !!Funcion methodsFor: 'control' stamp: 'Fede 5/1/2022 19:00'!encontrarEntradaVip|entrada|	entrada:= entradas detect: [ :x | ((x vendida) not) & (x isKindOf: EntradaVip)] ifNone: [entrada:= nil].	^entrada.! !!Funcion methodsFor: 'control' stamp: 'Fede 5/2/2022 20:17'!asString|res res2|	res:= ''.	res2:= ''.		res:= 'Codigo de funcion: ', codigo asString, ' | Fecha: ', fecha asString, ' | Entradas disponibles: ', String cr.	entradas do: [ :x| res2:= res2, x asString].		res:= res, res2.	^res.! !!Funcion methodsFor: 'control' stamp: 'Fede 5/1/2022 18:54'!importeTotalVendida|res|res:=0.entradas do: [ :x| (x vendida = true) ifTrue: [res := res + x importeFinal] ].^res! !!Funcion methodsFor: 'control' stamp: 'Fede 5/1/2022 18:16'!add: unaEntrada	entradas add: unaEntrada! !!Funcion methodsFor: 'initialization'!initialize	super initialize.	codigo := '0'.	fecha := Date newDay:1  month:(Date nameOfMonth: 1)  year:2000.	entradas := OrderedCollection new.		 ! !!Funcion methodsFor: 'acceso'!entradas"Devuelve las entradas que es una colection ordenada de todos los objects de la clase entradas que contiene la funcion"^entradas.! !!Funcion methodsFor: 'acceso'!codigo"Metodo de acceso a codigo"^codigo.! !!Funcion methodsFor: 'acceso'!fecha"Metodo de acceso de fecha"^fecha.! !!Funcion methodsFor: 'comparing' stamp: 'Fede 5/2/2022 19:54'!<= unaFuncion^self codigo <= unaFuncion codigo.! !!Funcion methodsFor: 'modificacion'!codigo: nuevoCodigo"Cambie el codigo de identificacion para nuevoCodigo"(nuevoCodigo isKindOf: Integer) ifTrue: [codigo:= nuevoCodigo].! !!Funcion methodsFor: 'modificacion'!fecha: nuevaFecha"Cambie el valor de fecha a nuevaFecha si es un objeto de la clase Date"	(nuevaFecha isKindOf: Date) ifTrue: [fecha := nuevaFecha].! !!Funcion methodsFor: 'modificacion'!entradas: nuevaColecion	(nuevaColecion isKindOf: OrderedCollection) ifTrue: [entradas := nuevaColecion].! !Object subclass: #ObraTeatro	instanceVariableNames: 'titulo direccion funciones'	classVariableNames: ''	package: 'Programa Teatro'!!ObraTeatro methodsFor: 'modificacion'!titulo: nuevoTitulo"Cambie el titulo a nuevoTitulo"(nuevoTitulo isKindOf: String) ifTrue: [titulo := nuevoTitulo].! !!ObraTeatro methodsFor: 'modificacion' stamp: 'Fede 5/2/2022 18:46'!direccion: nuevaDireccion"Cambie la dirreccion a nuevoDireccion un objeto de la clase Direccion si un objeto de la clase Direccion y devuelve True si la accion fue exito"	|mensaje|	mensaje := false.	(nuevaDireccion isKindOf: Direccion ) ifTrue: [direccion := nuevaDireccion. mensaje := true].	^mensaje! !!ObraTeatro methodsFor: 'modificacion'!funciones: nuevasFunciones(nuevasFunciones isKindOf: SortedCollection) ifTrue: [ funciones := nuevasFunciones].! !!ObraTeatro methodsFor: 'acceso'!funciones	^funciones.! !!ObraTeatro methodsFor: 'acceso'!asString"Devuelve el valor de todas las variables como String"|res|res := String cr, 'Titulo de la Obra: ', self titulo asString, ' - Director: ', self direccion asString.^res! !!ObraTeatro methodsFor: 'acceso'!titulo"Devulelve el titulo de la Obra"^titulo.! !!ObraTeatro methodsFor: 'acceso'!direccion"Devuelve la direccion (objeto de la clase Direccion) de la obra"^direccion.! !!ObraTeatro methodsFor: 'control' stamp: 'Fede 5/2/2022 21:20'!listadoOrdenadoNroButacasDisponiblesParaFuncion: unCodigo|res unaFuncion listaEntradas|res := String cr, 'Butacas disponibles para la función Nro: ', unCodigo asString.unaFuncion:= funciones detect:  [ :x | x codigo = unCodigo ] ifNone: [ res:= 'Funcion no encontrada' ].listaEntradas:= unaFuncion buscarEntradasNoVendidas.listaEntradas do: [ :x| res:= res, ' - ', x nroButaca asString. ].^res! !!ObraTeatro methodsFor: 'control' stamp: 'Fede 5/2/2022 21:22'!venderEntradaPlatea: unCodigo	|unaFuncion entrada res|	unaFuncion:= funciones detect:  [ :x | x codigo = unCodigo ] ifNone: [ res:= 'Funcion no encontrada' ].		entrada:= unaFuncion encontrarEntrada.	entrada isNotNil	ifTrue: [ res:= 'Entrada para la función ', unaFuncion codigo asString,' vendida con éxito!!', String cr, 'Codigo de la funcion: ', unaFuncion codigo asString, ' |Fecha de la funcion: ',  unaFuncion fecha asString, ' |Numero de butaca asignado: ', entrada nroButaca asString, ' |Importe final: ', entrada importeFinal asString. 		entrada vendida: true.]	ifFalse: [res:= 'No se encontro ninguna entrada de platea disponible para la venta.'  ].		^String cr, res.			! !!ObraTeatro methodsFor: 'control' stamp: 'Fede 5/2/2022 21:17'!importeTotalVentasFechaDesde: fechaMenor fechaHasta: fechaMayor|funcionesTmp res|res:=0.funcionesTmp := funciones select: [ :x| x fecha between: fechaMenor  and: fechaMayor].funcionesTmp do: [ :x| res := res + x importeTotalVendida].res:= String cr, 'El importe total desde: ', fechaMenor asString, ' Hasta: ', fechaMayor asString, ' es: ', res asString.^res! !!ObraTeatro methodsFor: 'control' stamp: 'Fede 5/2/2022 21:22'!venderEntradaVip: unCodigo aceptoServicioCatering: decision|unaFuncion entrada res|unaFuncion:= funciones detect:  [ :x | x codigo = unCodigo ] ifNone: [ res:= 'Funcion no encontrada' ].	entrada:= unaFuncion encontrarEntradaVip.	entrada isNotNil		ifTrue: [ 		entrada servicioCatering: decision.		res:= String cr, 'Entrada para la función ', unaFuncion codigo asString,' vendida con éxito!!', String cr, 'Codigo de la funcion: ', unaFuncion codigo asString, ' |Fecha de la funcion: ',  unaFuncion fecha asString, '| Acepta catering?: ', entrada servicioCatering asString, ' |Codigo de palco: ', entrada palco asString, ' |Importe final: ', entrada importeFinal asString, String cr.		entrada vendida: true.]	ifFalse: [res:= 'No se encontro ninguna entrada de platea disponible para la venta.'  ].	^res! !!ObraTeatro methodsFor: 'control' stamp: 'Fede 5/2/2022 19:52'!addFuncion: unaFuncion|msg temp|msg:= 'Funcion no agregada.'.temp:= funciones detect: [:x | x codigo = unaFuncion codigo] ifNone: [ temp:= nil ].	(unaFuncion isKindOf: Funcion) & temp isNil	ifTrue: [funciones add: unaFuncion.		msg:= 'Funcion agregada con exito.'].	^msg.	! !!ObraTeatro methodsFor: 'control' stamp: 'Fede 5/2/2022 19:56'!habilitarEntrada: unaEntrada aFuncion: unCodigo|temp msg|msg:= 'Entrada no agregada.'. temp:= funciones detect: [ :x | (x codigo = unCodigo)] ifNone: [ temp:= nil. ].	temp isNotNil ifTrue: [ temp add: unaEntrada.		msg:= 'Entrada agregada con exito.' ].		^msg		! !!ObraTeatro methodsFor: 'inicializacion' stamp: 'Fede 5/1/2022 17:30'!initializesuper initialize.titulo := ''.direccion := ''.funciones:= SortedCollection new.! !Object subclass: #Palco	instanceVariableNames: 'cantidadAsientos codigo'	classVariableNames: ''	package: 'Programa Teatro'!!Palco methodsFor: 'modificacion'!cantidadAsientos: nuevaCantidad"Cambie el valor de cantidadAsientos a nuevaCantidad"(cantidadAsientos isKindOf: Integer) ifTrue: [cantidadAsientos := nuevaCantidad].! !!Palco methodsFor: 'modificacion' stamp: 'Fede 5/2/2022 20:43'!codigo: nuevoCodigo"Cambie el valor de la variable codigo a nuevoCodigo"|validador|validador:= #(A B C D E F).(nuevoCodigo isKindOf: String) & (validador includes: nuevoCodigo) ifTrue: [codigo := nuevoCodigo].! !!Palco methodsFor: 'inicializacion' stamp: 'Fede 5/1/2022 17:13'!initializesuper initialize.codigo := 'Todavia no asignado'.cantidadAsientos := 0. "Default cero"! !!Palco methodsFor: 'acceso'!cantidadAsientos"Metodo de acceso a la cantidad de Asientos del Palco"^cantidadAsientos.! !!Palco methodsFor: 'acceso' stamp: 'Fede 5/2/2022 20:43'!asString"Devuelve el valor de todas las variables como String"|res|res := self codigo asString, ' - Cantidad de Asientos disponible: ', self cantidadAsientos asString.^res! !!Palco methodsFor: 'acceso'!codigo"Metodo de aceso a la variable codigo que identeifica el palco"^codigo.! !